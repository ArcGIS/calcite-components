import { DeepKeyTokenMap, SingleToken } from "@tokens-studio/types";
import { TransformOptions, Expandables, ExpandablesAsStrings, expandablesAsStrings } from "../TransformOptions.js";
import { matchPlaceholderElement, tokenStudioCustomVariableIndicator } from "../utils/regex.js";
import { shouldExpand, expandToken } from "../utils/compositeTokens.js";
import { convertTokenToStyleDictionaryFormat } from "../utils/convertTokenToStyleDictionaryFormat.js";

/**
 * Figma Token Studio creates an odd type of composite token where the value may contain an object of "key: value" pairs.
 * Here we will lift these composite tokens up to match the Style Dictionary format.
 * @param {DeepKeyTokenMap<false>} dictionary the raw JSON object in the token files. We will assume this is a token object generated by Figma Token Studio and may require composite tokens to be expanded.
 * @param {string} filePath the absolute file path to the JSON token file.
 * @param {TransformOptions} transformOpts the options passed in from the Style Dictionary config and runner
 * @returns {DeepKeyTokenMap<false>} a token object where any Figma Token Studio composite tokens now match the Style Dictionary token format
 */
export function expandComposites(
  dictionary: DeepKeyTokenMap<false>,
  filePath: string,
  transformOpts: TransformOptions = {}
): DeepKeyTokenMap<false> {
  const opts = {
    ...transformOpts,
    expand: {
      composition: true,
      typography: false,
      border: false,
      shadow: false,
      ...transformOpts.expand
    }
  };
  const returnSlice: DeepKeyTokenMap<false> = {};
  const handleTokenStudioVariables = convertTokenToStyleDictionaryFormat(tokenStudioCustomVariableIndicator);
  const newDictionary = Object.entries(dictionary).reduce((acc, [key, token]) => {
    const { type } = token;
    if (matchPlaceholderElement.test(`${key}`) || matchPlaceholderElement.test(`${token.value}`)) {
      return acc;
    }

    if (token.value && type) {
      // @ts-expect-error - we can count on this type being a string
      if (typeof type === "string" && expandablesAsStrings.includes(type)) {
        const expandType = (type as ExpandablesAsStrings) === "boxShadow" ? "shadow" : type;
        const expand = shouldExpand<Expandables>(token as Expandables, opts.expand[expandType], filePath);
        if (expand) {
          const expandedToken = expandToken(
            token as SingleToken<false>,
            expandType === "shadow",
            handleTokenStudioVariables
          );
          acc[key] = expandedToken;
        }
      } else {
        token.value = handleTokenStudioVariables(token.value as string);
        acc[key] = token;
      }
    } else if (typeof token === "object") {
      acc[key] = expandComposites(token as unknown as DeepKeyTokenMap<false>, filePath, transformOpts);
    }
    return acc;
  }, returnSlice);

  return newDictionary;
}
